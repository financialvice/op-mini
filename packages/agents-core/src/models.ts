// Auto-generated by scripts/populate-models.ts in agents-server
// Do not edit manually - run: bun run populate-models in apps/agents-server

import type { Provider } from "./provider";

/**
 * Reasoning levels as numeric values (0-4) for natural ordering.
 * Higher numbers = more reasoning/thinking tokens.
 */
export const REASONING_LEVELS = [0, 1, 2, 3, 4] as const;
export type ReasoningLevel = (typeof REASONING_LEVELS)[number];

/**
 * Metadata for each reasoning level including provider-specific mappings.
 */
export type ReasoningLevelMeta = {
  level: ReasoningLevel;
  name: string;
  label: string;
  codex: "minimal" | "low" | "medium" | "high" | "xhigh";
  claudeTokens: number;
};

export const REASONING_LEVEL_META: readonly [
  ReasoningLevelMeta,
  ReasoningLevelMeta,
  ReasoningLevelMeta,
  ReasoningLevelMeta,
  ReasoningLevelMeta,
] = [
  { level: 0, name: "none", label: "None", codex: "minimal", claudeTokens: 0 },
  { level: 1, name: "low", label: "Low", codex: "low", claudeTokens: 4000 },
  {
    level: 2,
    name: "medium",
    label: "Medium",
    codex: "medium",
    claudeTokens: 10_000,
  },
  {
    level: 3,
    name: "high",
    label: "High",
    codex: "high",
    claudeTokens: 20_000,
  },
  { level: 4, name: "max", label: "Max", codex: "xhigh", claudeTokens: 32_000 },
] as const;

/**
 * Get metadata for a reasoning level.
 */
export function getReasoningMeta(level: ReasoningLevel): ReasoningLevelMeta {
  return REASONING_LEVEL_META[level];
}

export type ModelInfo = {
  value: string;
  displayName: string;
  supportedReasoningLevels: readonly ReasoningLevel[];
};

export const CODEX_MODELS: readonly ModelInfo[] = [
  {
    value: "gpt-5",
    displayName: "GPT 5",
    supportedReasoningLevels: [0, 1, 2, 3],
  },
  {
    value: "gpt-5-codex",
    displayName: "GPT 5 Codex",
    supportedReasoningLevels: [1, 2, 3],
  },
  {
    value: "gpt-5-codex-mini",
    displayName: "GPT 5 Codex Mini",
    supportedReasoningLevels: [2, 3],
  },
  {
    value: "gpt-5.1",
    displayName: "GPT 5.1",
    supportedReasoningLevels: [1, 2, 3],
  },
  {
    value: "gpt-5.1-codex",
    displayName: "GPT 5.1 Codex",
    supportedReasoningLevels: [1, 2, 3],
  },
  {
    value: "gpt-5.1-codex-max",
    displayName: "GPT 5.1 Codex Max",
    supportedReasoningLevels: [1, 2, 3, 4],
  },
  {
    value: "gpt-5.1-codex-mini",
    displayName: "GPT 5.1 Codex Mini",
    supportedReasoningLevels: [2, 3],
  },
] as const;

export const CLAUDE_MODELS: readonly ModelInfo[] = [
  {
    value: "default",
    displayName: "Opus 4.5",
    supportedReasoningLevels: [0, 1, 2, 3, 4],
  },
  {
    value: "haiku",
    displayName: "Haiku 4.5",
    supportedReasoningLevels: [0, 1, 2, 3, 4],
  },
  {
    value: "sonnet",
    displayName: "Sonnet 4.5",
    supportedReasoningLevels: [0, 1, 2, 3, 4],
  },
] as const;

export type CodexModel = (typeof CODEX_MODELS)[number]["value"];
export type ClaudeModel = (typeof CLAUDE_MODELS)[number]["value"];

export const DEFAULT_CODEX_MODEL: CodexModel = "gpt-5.1-codex-max";
export const DEFAULT_CLAUDE_MODEL: ClaudeModel = "default";
export const DEFAULT_REASONING_LEVEL: ReasoningLevel = 2;

/**
 * Get model info by model value. Returns undefined if model not found.
 */
export function getModelInfo(
  model: string,
  provider: Provider
): ModelInfo | undefined {
  const models = provider === "claude" ? CLAUDE_MODELS : CODEX_MODELS;
  return models.find((m) => m.value === model);
}

/**
 * Get supported reasoning levels for a model.
 * Returns all levels if model not found (for unknown/custom models).
 */
export function getSupportedReasoningLevels(
  model: string,
  provider: Provider
): readonly ReasoningLevel[] {
  const info = getModelInfo(model, provider);
  return info?.supportedReasoningLevels ?? REASONING_LEVELS;
}

/**
 * Check if a reasoning level is supported for a model.
 */
export function isReasoningLevelSupported(
  model: string,
  provider: Provider,
  level: ReasoningLevel
): boolean {
  const supported = getSupportedReasoningLevels(model, provider);
  return supported.includes(level);
}

/**
 * Validate reasoning level for a model. Throws if unsupported.
 */
export function validateReasoningLevel(
  model: string,
  provider: Provider,
  level: ReasoningLevel
): void {
  if (!isReasoningLevelSupported(model, provider, level)) {
    const supported = getSupportedReasoningLevels(model, provider);
    const levelMeta = getReasoningMeta(level);
    const supportedNames = supported
      .map((l) => getReasoningMeta(l).name)
      .join(", ");
    throw new Error(
      `Reasoning level "${levelMeta.name}" (level ${level}) is not supported for model "${model}". Supported levels: ${supportedNames}`
    );
  }
}
